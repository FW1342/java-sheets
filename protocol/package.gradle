import java.nio.file.Files
import java.nio.file.Path
import java.util.stream.Collectors
import java.util.stream.Stream

final class GeneratedService {
  String name
  Path directory

  Stream<GeneratedFile> list() {
    def existing = listExistingFiles()
    def index = createIndexFile()
    return Stream.concat(existing, Stream.of(index))
  }

  private def createIndexFile() {
    return new IndexFile(serviceName: name)
  }

  private def listExistingFiles() {
    return Files.list(directory)
      .filter { Files.isRegularFile(it) }
      .map {
        return new SourceFile(
          path: it,
          serviceName: name
        )
      }
  }
}

interface GeneratedFile {
  void writeTo(Path directory)
}

interface GeneratedServiceFile extends GeneratedFile {
  Path createPath(Path sourceDirectory)
}

final class SourceFile implements GeneratedServiceFile {
  String serviceName
  Path path

  @Override
  void writeTo(Path directory) {
    def content = processContent()
    def filePath = createPath(directory)
    MoreFiles.writeString(filePath, String.valueOf(content))
  }

  @Override
  Path createPath(Path directory) {
    return directory
      .resolve(serviceName)
      .resolve(selectGeneratedName())
  }

  private def processContent() {
    def content = Files.readString(path)
    return process(content)
  }

  private static def process(String content) {
    return '// Processed by JSheets Protobuf Packager\n' + content
  }

  private def selectGeneratedName() {
    return path.fileName.toString()
  }
}

final class IndexFile implements GeneratedServiceFile {
  String serviceName

  @Override
  void writeTo(Path directory) {
    def filePath = createPath(directory)
    MoreFiles.writeString(filePath, generateContent())
  }

  @Override
  Path createPath(Path directory) {
    return directory.resolve(serviceName).resolve('index.ts')
  }

  private def generateContent() {
    return """// Generated by protobuf p
export * from './${serviceName}_service_grpc_web_pb'
export * from './${serviceName}_service_pb'
    """
  }
}

final class StaticContentFile implements GeneratedFile {
  Path name
  String content

  @Override
  void writeTo(Path directory) {
    def filePath = directory.resolve(name)
    MoreFiles.writeString(filePath, content)
  }
}

final class GeneratedLibrary {
  Path outputDirectory
  Path destination
  String version

  void generate() {
    generateServiceFiles().each { it.writeTo(destination.resolve ("src/jsheets")) }
    generateLibraryFiles().each { it.writeTo(destination) }
  }

  private Collection<GeneratedFile> generateLibraryFiles() {
    def files = new ArrayList<GeneratedFile>()
    files.addAll(Arrays.asList(generateConfigurations()))
    files.addAll(Arrays.asList(generateSpecialFiles()))
    return files
  }

  private GeneratedFile[] generateServiceFiles() {
    return createFilesForService().stream()
      .map { Arrays.stream(it) }
      .flatMap { it }
      .toArray { new GeneratedFile[it] }
  }

  private GeneratedFile[] generateConfigurations() {
    return [generatePackageConfig()]
  }

  private static GeneratedFile[] generateSpecialFiles() {
    return [generateIndexFile()]
  }

  private static GeneratedFile generateIndexFile() {
    return new StaticContentFile(
      content: '',
      name: Path.of('index.js')
    )
  }

  private def generatePackageConfig() {
    def content = """
    {
      "name": "@jsheets/protocol",
      "version": "$version",
      "description": "JSheets protocol",
      "license": "MIT",
      "main": "index.js",
      "files": ["src"]
    }
    """.stripIndent().strip()
    return new StaticContentFile(
      content: content,
      name: Path.of('package.json')
    )
  }

  private static def toUnixPath(Path path) {
    return path.toString().replace("\\", "/")
  }

  private Collection<GeneratedFile> createFilesForService() {
    return listServicesInDirectory(outputDirectory)
      .map { it.list() }
      .flatMap { it }
      .toArray { new GeneratedFile[it] }
  }

  private static boolean isServiceContainer(Path path) {
    return Files.isDirectory(path) && containsFiles(path)
  }

  private static boolean containsFiles(Path path) {
    return Files.list(path).withCloseable { directory ->
      directory.anyMatch { Files.isRegularFile(it) }
    }
  }

  private Stream<GeneratedService> listServicesInDirectory(Path directory) {
    if (!Files.isDirectory(directory)) {
      return Stream.empty()
    }
    return Files.walk(directory).withCloseable { files ->
      files.filter { isServiceContainer(it) }
        .map {
          def fileName = it.fileName.toString()
          new GeneratedService(name: fileName, directory: it)
        }
        .collect(Collectors.toList())
        .stream()
    }

  }
}

final class MoreFiles {
  private MoreFiles() {}

  static void writeString(Path path, String content) {
    createIfNotExists(path)
    Files.writeString(path, content)
  }

  static void createIfNotExists(Path path) {
    if (Files.exists(path)) {
      return
    }
    if (path.getParent() != null) {
      Files.createDirectories(path.getParent())
    }
    Files.createFile(path)
  }
}

task generateJavascriptPackage {
  doLast {
    def generation =new GeneratedLibrary(
      version: version,
      outputDirectory: project.projectDir.toPath().resolve('build/generated/source/proto/main/js'),
      destination: project.projectDir.toPath().resolve ("generated/js-protocol"),
    )
    generation.generate()
  }
}